/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../../common";

export type BinMarginStruct = {
  tradingFeeRate: BigNumberish;
  amount: BigNumberish;
};

export type BinMarginStructOutput = [tradingFeeRate: bigint, amount: bigint] & {
  tradingFeeRate: bigint;
  amount: bigint;
};

export type PositionStruct = {
  id: BigNumberish;
  openVersion: BigNumberish;
  closeVersion: BigNumberish;
  qty: BigNumberish;
  openTimestamp: BigNumberish;
  closeTimestamp: BigNumberish;
  takerMargin: BigNumberish;
  owner: AddressLike;
  _binMargins: BinMarginStruct[];
  _feeProtocol: BigNumberish;
};

export type PositionStructOutput = [
  id: bigint,
  openVersion: bigint,
  closeVersion: bigint,
  qty: bigint,
  openTimestamp: bigint,
  closeTimestamp: bigint,
  takerMargin: bigint,
  owner: string,
  _binMargins: BinMarginStructOutput[],
  _feeProtocol: bigint
] & {
  id: bigint;
  openVersion: bigint;
  closeVersion: bigint;
  qty: bigint;
  openTimestamp: bigint;
  closeTimestamp: bigint;
  takerMargin: bigint;
  owner: string;
  _binMargins: BinMarginStructOutput[];
  _feeProtocol: bigint;
};

export interface MarketTradeFacetInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "claimPosition"
      | "closePosition"
      | "getPositions"
      | "openPosition"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ClaimPosition"
      | "ClosePosition"
      | "OpenPosition"
      | "TransferProtocolFee"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "claimPosition",
    values: [BigNumberish, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "closePosition",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPositions",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "openPosition",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "claimPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "openPosition",
    data: BytesLike
  ): Result;
}

export namespace ClaimPositionEvent {
  export type InputTuple = [
    account: AddressLike,
    pnl: BigNumberish,
    interest: BigNumberish,
    position: PositionStruct
  ];
  export type OutputTuple = [
    account: string,
    pnl: bigint,
    interest: bigint,
    position: PositionStructOutput
  ];
  export interface OutputObject {
    account: string;
    pnl: bigint;
    interest: bigint;
    position: PositionStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ClosePositionEvent {
  export type InputTuple = [account: AddressLike, position: PositionStruct];
  export type OutputTuple = [account: string, position: PositionStructOutput];
  export interface OutputObject {
    account: string;
    position: PositionStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OpenPositionEvent {
  export type InputTuple = [account: AddressLike, position: PositionStruct];
  export type OutputTuple = [account: string, position: PositionStructOutput];
  export interface OutputObject {
    account: string;
    position: PositionStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferProtocolFeeEvent {
  export type InputTuple = [positionId: BigNumberish, amount: BigNumberish];
  export type OutputTuple = [positionId: bigint, amount: bigint];
  export interface OutputObject {
    positionId: bigint;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface MarketTradeFacet extends BaseContract {
  connect(runner?: ContractRunner | null): MarketTradeFacet;
  waitForDeployment(): Promise<this>;

  interface: MarketTradeFacetInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  /**
   * Claims the position by transferring the available funds to the recipient.      The caller must be the owner of the position.      The position must be eligible for claim in the current oracle version.      The claimed amount is determined based on the position's profit and loss (pnl).      Throws a `NotExistPosition` error if the requested position does not exist.      Throws a `NotPermitted` error if the caller is not permitted to perform the action as they are not the owner of the position.      Throws a `NotClaimablePosition` error if the position cannot be claimed as it is not eligible for claim in the current oracle version.      Throws a `ClaimPositionCallbackError` error if an error occurred during the claim position callback.
   * @param data Additional data for the claim callback.
   * @param positionId The ID of the position to claim.
   * @param recipient The address of the recipient of the claimed position.
   */
  claimPosition: TypedContractMethod<
    [positionId: BigNumberish, recipient: AddressLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  /**
   * This function allows the owner of the position to close it. The position must exist, be owned by the caller,      and not have already been closed. Upon successful closure, the position is settled, and a `ClosePosition` event is emitted.      If the position is closed in a different oracle version than the open version, a claim position task is created by the liquidator.      Otherwise, the position is immediately claimed, and a `ClaimPosition` event is emitted.      Throws a `NotExistPosition` error if the specified position does not exist.      Throws a `NotPermitted` error if the caller is not the owner of the position.      Throws an `AlreadyClosedPosition` error if the position has already been closed.      Throws a `ClaimPositionCallbackError` error if an error occurred during the claim position callback.
   * @param positionId The ID of the position to close.
   */
  closePosition: TypedContractMethod<
    [positionId: BigNumberish],
    [PositionStructOutput],
    "nonpayable"
  >;

  /**
   * Retrieves multiple positions by their IDs.
   * @param positionIds The IDs of the positions to retrieve.
   */
  getPositions: TypedContractMethod<
    [positionIds: BigNumberish[]],
    [PositionStructOutput[]],
    "view"
  >;

  /**
   * Throws a `TooSmallTakerMargin` error if the `takerMargin` is smaller than the minimum required margin for the settlement token.      Throws an `ExceedMaxAllowableLeverage` if the leverage exceeds the maximum allowable leverage.      Throws a `NotAllowableMakerMargin` if the maker margin is not within the allowable range based on the absolute quantity and min/max take-profit basis points (BPS).      Throws an `ExceedMaxAllowableTradingFee` if the total trading fee (including protocol fee) exceeds the maximum allowable trading fee (`maxAllowableTradingFee`).      Throws a `NotEnoughMarginTransferred` if the margin settlement token balance did not increase by the required margin amount after the callback. Requirements:  - The `takerMargin` must be greater than or equal to the minimum required margin for the settlement token.  - The position parameters must pass the validity check, including leverage limits and allowable margin ranges.  - The position is assigned a new ID and stored in the position storage.  - A keeper task for potential liquidation is created by the liquidator.  - An `OpenPosition` event is emitted with the owner's address and the newly opened position details.
   * @param data Additional data for the position callback.
   * @param makerMargin The margin amount provided by the maker.
   * @param maxAllowableTradingFee The maximum allowable trading fee for the position.
   * @param qty The quantity of the position.
   * @param takerMargin The margin amount provided by the taker.
   */
  openPosition: TypedContractMethod<
    [
      qty: BigNumberish,
      takerMargin: BigNumberish,
      makerMargin: BigNumberish,
      maxAllowableTradingFee: BigNumberish,
      data: BytesLike
    ],
    [PositionStructOutput],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "claimPosition"
  ): TypedContractMethod<
    [positionId: BigNumberish, recipient: AddressLike, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "closePosition"
  ): TypedContractMethod<
    [positionId: BigNumberish],
    [PositionStructOutput],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getPositions"
  ): TypedContractMethod<
    [positionIds: BigNumberish[]],
    [PositionStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "openPosition"
  ): TypedContractMethod<
    [
      qty: BigNumberish,
      takerMargin: BigNumberish,
      makerMargin: BigNumberish,
      maxAllowableTradingFee: BigNumberish,
      data: BytesLike
    ],
    [PositionStructOutput],
    "nonpayable"
  >;

  getEvent(
    key: "ClaimPosition"
  ): TypedContractEvent<
    ClaimPositionEvent.InputTuple,
    ClaimPositionEvent.OutputTuple,
    ClaimPositionEvent.OutputObject
  >;
  getEvent(
    key: "ClosePosition"
  ): TypedContractEvent<
    ClosePositionEvent.InputTuple,
    ClosePositionEvent.OutputTuple,
    ClosePositionEvent.OutputObject
  >;
  getEvent(
    key: "OpenPosition"
  ): TypedContractEvent<
    OpenPositionEvent.InputTuple,
    OpenPositionEvent.OutputTuple,
    OpenPositionEvent.OutputObject
  >;
  getEvent(
    key: "TransferProtocolFee"
  ): TypedContractEvent<
    TransferProtocolFeeEvent.InputTuple,
    TransferProtocolFeeEvent.OutputTuple,
    TransferProtocolFeeEvent.OutputObject
  >;

  filters: {
    "ClaimPosition(address,int256,uint256,tuple)": TypedContractEvent<
      ClaimPositionEvent.InputTuple,
      ClaimPositionEvent.OutputTuple,
      ClaimPositionEvent.OutputObject
    >;
    ClaimPosition: TypedContractEvent<
      ClaimPositionEvent.InputTuple,
      ClaimPositionEvent.OutputTuple,
      ClaimPositionEvent.OutputObject
    >;

    "ClosePosition(address,tuple)": TypedContractEvent<
      ClosePositionEvent.InputTuple,
      ClosePositionEvent.OutputTuple,
      ClosePositionEvent.OutputObject
    >;
    ClosePosition: TypedContractEvent<
      ClosePositionEvent.InputTuple,
      ClosePositionEvent.OutputTuple,
      ClosePositionEvent.OutputObject
    >;

    "OpenPosition(address,tuple)": TypedContractEvent<
      OpenPositionEvent.InputTuple,
      OpenPositionEvent.OutputTuple,
      OpenPositionEvent.OutputObject
    >;
    OpenPosition: TypedContractEvent<
      OpenPositionEvent.InputTuple,
      OpenPositionEvent.OutputTuple,
      OpenPositionEvent.OutputObject
    >;

    "TransferProtocolFee(uint256,uint256)": TypedContractEvent<
      TransferProtocolFeeEvent.InputTuple,
      TransferProtocolFeeEvent.OutputTuple,
      TransferProtocolFeeEvent.OutputObject
    >;
    TransferProtocolFee: TypedContractEvent<
      TransferProtocolFeeEvent.InputTuple,
      TransferProtocolFeeEvent.OutputTuple,
      TransferProtocolFeeEvent.OutputObject
    >;
  };
}
