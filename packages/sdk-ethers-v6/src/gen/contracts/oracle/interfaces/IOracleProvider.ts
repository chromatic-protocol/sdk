/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../../common";

export declare namespace IOracleProvider {
  export type OracleVersionStruct = {
    version: BigNumberish;
    timestamp: BigNumberish;
    price: BigNumberish;
  };

  export type OracleVersionStructOutput = [
    version: bigint,
    timestamp: bigint,
    price: bigint
  ] & { version: bigint; timestamp: bigint; price: bigint };
}

export interface IOracleProviderInterface extends Interface {
  getFunction(
    nameOrSignature: "atVersion" | "currentVersion" | "description" | "sync"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "atVersion",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "currentVersion",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "description",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "sync", values?: undefined): string;

  decodeFunctionResult(functionFragment: "atVersion", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "currentVersion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "description",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sync", data: BytesLike): Result;
}

export interface IOracleProvider extends BaseContract {
  connect(runner?: ContractRunner | null): IOracleProvider;
  waitForDeployment(): Promise<this>;

  interface: IOracleProviderInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  /**
   * Returns the current oracle version
   * @param version The version of which to lookup
   */
  atVersion: TypedContractMethod<
    [version: BigNumberish],
    [IOracleProvider.OracleVersionStructOutput],
    "view"
  >;

  /**
   * Returns the current oracle version
   */
  currentVersion: TypedContractMethod<
    [],
    [IOracleProvider.OracleVersionStructOutput],
    "view"
  >;

  /**
   * Retrieves the description of the Oracle Provider.
   */
  description: TypedContractMethod<[], [string], "view">;

  /**
   * `sync` is expected to be called soon after a phase update occurs in the underlying proxy.      Phase updates should be detected using off-chain mechanism and should trigger a `sync` call      This is feasible in the short term due to how infrequent phase updates are, but phase update      and roundCount detection should eventually be implemented at the contract level.      Reverts if there is more than 1 phase to update in a single sync because we currently cannot      determine the startingRoundId for the intermediary phase.
   * Checks for a new price and updates the internal phase annotation state accordingly
   */
  sync: TypedContractMethod<
    [],
    [IOracleProvider.OracleVersionStructOutput],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "atVersion"
  ): TypedContractMethod<
    [version: BigNumberish],
    [IOracleProvider.OracleVersionStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "currentVersion"
  ): TypedContractMethod<
    [],
    [IOracleProvider.OracleVersionStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "description"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "sync"
  ): TypedContractMethod<
    [],
    [IOracleProvider.OracleVersionStructOutput],
    "nonpayable"
  >;

  filters: {};
}
